<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/mattdesl/budo"

    >budo (v9.4.7)</a>
</h1>
<h4>a browserify server for rapid prototyping</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo">module budo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.budo">
            function <span class="apidocSignatureSpan"></span>budo
            <span class="apidocSignatureSpan">(entries, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.bundler">
            function <span class="apidocSignatureSpan">budo.</span>bundler
            <span class="apidocSignatureSpan">(files, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.cli">
            function <span class="apidocSignatureSpan">budo.</span>cli
            <span class="apidocSignatureSpan">(args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.error_handler">
            function <span class="apidocSignatureSpan">budo.</span>error_handler
            <span class="apidocSignatureSpan">(err, cwd, rootDirName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.file_watch">
            function <span class="apidocSignatureSpan">budo.</span>file_watch
            <span class="apidocSignatureSpan">(glob, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.get_ports">
            function <span class="apidocSignatureSpan">budo.</span>get_ports
            <span class="apidocSignatureSpan">(opt, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.map_entry">
            function <span class="apidocSignatureSpan">budo.</span>map_entry
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.middleware">
            function <span class="apidocSignatureSpan">budo.</span>middleware
            <span class="apidocSignatureSpan">(entryMiddleware, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.parse_args">
            function <span class="apidocSignatureSpan">budo.</span>parse_args
            <span class="apidocSignatureSpan">(args, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.server">
            function <span class="apidocSignatureSpan">budo.</span>server
            <span class="apidocSignatureSpan">(entryMiddleware, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.simple_http_logger">
            function <span class="apidocSignatureSpan">budo.</span>simple_http_logger
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.tinylr">
            function <span class="apidocSignatureSpan">budo.</span>tinylr
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.toString">
            function <span class="apidocSignatureSpan">budo.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.bundler">module budo.bundler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.bundler.bundler">
            function <span class="apidocSignatureSpan">budo.</span>bundler
            <span class="apidocSignatureSpan">(files, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.cli">module budo.cli</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.cli.cli">
            function <span class="apidocSignatureSpan">budo.</span>cli
            <span class="apidocSignatureSpan">(args, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.error_handler">module budo.error_handler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.error_handler.error_handler">
            function <span class="apidocSignatureSpan">budo.</span>error_handler
            <span class="apidocSignatureSpan">(err, cwd, rootDirName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.error_handler.render">
            function <span class="apidocSignatureSpan">budo.error_handler.</span>render
            <span class="apidocSignatureSpan">(message, cwd, rootDirName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.file_watch">module budo.file_watch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.file_watch.file_watch">
            function <span class="apidocSignatureSpan">budo.</span>file_watch
            <span class="apidocSignatureSpan">(glob, opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">budo.file_watch.</span>ignores</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.get_ports">module budo.get_ports</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.get_ports.get_ports">
            function <span class="apidocSignatureSpan">budo.</span>get_ports
            <span class="apidocSignatureSpan">(opt, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.map_entry">module budo.map_entry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.map_entry.map_entry">
            function <span class="apidocSignatureSpan">budo.</span>map_entry
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.middleware">module budo.middleware</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.middleware.middleware">
            function <span class="apidocSignatureSpan">budo.</span>middleware
            <span class="apidocSignatureSpan">(entryMiddleware, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.parse_args">module budo.parse_args</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.parse_args.parse_args">
            function <span class="apidocSignatureSpan">budo.</span>parse_args
            <span class="apidocSignatureSpan">(args, opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">budo.parse_args.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.server">module budo.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.server.server">
            function <span class="apidocSignatureSpan">budo.</span>server
            <span class="apidocSignatureSpan">(entryMiddleware, opts, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.simple_http_logger">module budo.simple_http_logger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.simple_http_logger.simple_http_logger">
            function <span class="apidocSignatureSpan">budo.</span>simple_http_logger
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.tinylr">module budo.tinylr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.tinylr.tinylr">
            function <span class="apidocSignatureSpan">budo.</span>tinylr
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.toString">module budo.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.toString.toString">
            function <span class="apidocSignatureSpan">budo.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo" id="apidoc.module.budo">module budo</a></h1>


    <h2>
        <a href="#apidoc.element.budo.budo" id="apidoc.element.budo.budo">
        function <span class="apidocSignatureSpan"></span>budo
        <span class="apidocSignatureSpan">(entries, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBudo(entries, opts) {
  var log = bole(&#x27;budo&#x27;)

  // if no entries are specified, just options
  if (entries &#x26;&#x26; !Array.isArray(entries) &#x26;&#x26; typeof entries === &#x27;object&#x27;) {
    opts = entries
    entries = []
  }

  // do not mutate user options
  opts = xtend({}, defaults, { stream: false }, opts)
  entries = entries || []

  // perhaps later this will be configurable
  opts.cwd = process.cwd()

  // log to output stream
  if (opts.stream) {
    // by default, pretty-print to the stream with info logging
    if (!opts.ndjson) {
      var pretty = garnish({
        level: opts.verbose ? &#x27;debug&#x27; : &#x27;info&#x27;,
        name: &#x27;budo&#x27;
      })
      pretty.pipe(opts.stream)
      opts.stream = pretty
    }

    bole.output({
      stream: opts.stream,
      level: &#x27;debug&#x27;
    })
  }

  // optionally allow as arrays
  entries = [].concat(entries).filter(Boolean)

  var entryObjects = entries.map(mapEntry)
  var entryFiles = entryObjects.map(function (entry) {
    return entry.from
  })

  if (opts.serve &#x26;&#x26; typeof opts.serve !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;opts.serve must be a string or undefined&#x27;)
  } else if (!opts.serve &#x26;&#x26; entries.length &#x3e; 0) {
    opts.serve = entryObjects[0].url
  }

  // default to cwd
  if (!opts.dir || opts.dir.length === 0) {
    opts.dir = opts.cwd
  }

  var emitter = new EventEmitter()
  var bundler, middleware

  if (entries.length &#x3e; 0 || (opts.browserify &#x26;&#x26; opts.browserify.entries)) {
    bundler = createBundler(entryFiles, opts)
    middleware = bundler.middleware

    bundler.on(&#x27;log&#x27;, function (ev) {
      if (ev.type === &#x27;bundle&#x27;) {
        var time = ev.elapsed
        ev.elapsed = time
        ev.name = &#x27;browserify&#x27;
        ev.type = undefined
        ev.colors = {
          elapsed: time &#x3e; 1000 ? &#x27;yellow&#x27; : &#x27;dim&#x27;,
          message: &#x27;dim &#x27;
        }
        log.info(ev)
      }
    })

    // uncaught syntax errors should not stop the server
    // this only happens when errorHandler: false
    bundler.on(&#x27;error&#x27;, function (err) {
      console.error(&#x27;Error:&#x27;, err.message ? err.message : err)
    })
    bundler.on(&#x27;bundle-error&#x27;, emitter.emit.bind(emitter, &#x27;bundle-error&#x27;))
    bundler.on(&#x27;update&#x27;, emitter.emit.bind(emitter, &#x27;update&#x27;))
    bundler.on(&#x27;pending&#x27;, emitter.emit.bind(emitter, &#x27;pending&#x27;))

    emitter.on(&#x27;update&#x27;, function (contents, deps) {
      if (deps.length &#x3e; 1) {
        log.debug({
          name: &#x27;browserify&#x27;,
          message: deps.length + &#x27; files changed&#x27;
        })
      }
    })
  }

  var defaultWatchGlob = opts.watchGlob || &#x27;**/*.{html,css}&#x27;
  var server = null
  var closed = false
  var started = false
  var fileWatcher = null
  var tinylr = null
  var sslOpts = null // needed for livereload
  var deferredWatch = noop
  var deferredLive = noop

  // keep track of the original host
  // (can be undefined)
  var hostAddress = opts.host

  // public API
  emitter.close = once(close)
  emitter.reload = reload
  emitter.live = live
  emitter.watch = watch

  // setup defaults for live reload / watchify
  if (opts.live) {
    emitter
      .watch()
      .live()
      .on(&#x27;watch&#x27;, function (ev, file) {
        if (ev !== &#x27;change&#x27; &#x26;&#x26; ev !== &#x27;add&#x27;) {
          return
        }
        defaultFileEvent(file)
      })
      .on(&#x27;pending&#x27;, function () {
        defaultFileEvent(opts.serve)
      })
  }

  // First, setup a server
  createServer(middleware, opts, function (err, serverInstance, httpsCertKey) {
    if (err) {
      emitter.emit(&#x27;error&#x27;, err)
      return
    }

    server = serverInstance
    sslOpts = httpsCertKey

    // start portfinding + connect
    getPorts(opts, handlePorts)
  })

  return emitter

  function defaultFileEvent (file) {
    var filename = path.basename(file)
    if ((Array.isArray(opts.live) || typeof opts.live === &#x27;string&#x27;) &#x26;&#x26;
        isMatch(filename, opts.live).length === 0) {
      return
    }
    emitter.reload(file)
  }

  function reload (file) {
    process.nextTick(emitter.emit.bind(emitter, &#x27;reload&#x27;, file))
    if (tinylr) {
      tinylr.reload(file)
    }
  }

  // enable file watch capabilities
  function watc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.bundler" id="apidoc.element.budo.bundler">
        function <span class="apidocSignatureSpan">budo.</span>bundler
        <span class="apidocSignatureSpan">(files, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBundler(files, opts) {
  var bOpts = xtend({
    cache: {},
    packageCache: {},
    debug: opts.debug
  }, opts.browserify)

  var bundler
  var args = opts.browserifyArgs
  if (args &#x26;&#x26; Array.isArray(args)) {
    // CLI args for browserify
    bundler = fromArgs(args, bOpts)
  } else {
    // just assume JS only options
    bundler = browserify(bOpts)
  }

  files.forEach(function (file) {
    bundler.add(path.resolve(file))
  })

  var errorHandler = opts.errorHandler
  if (typeof errorHandler !== &#x27;function&#x27; &#x26;&#x26; errorHandler !== false) {
    errorHandler = defaultErrorHandler
  }

  var cwd = opts.cwd
  var rootDirName
  if (cwd) {
    cwd = path.normalize(cwd)
    rootDirName = path.basename(cwd) + path.sep
  }
  return createMiddleware(bundler, {
    delay: opts.delay || 0,
    initialBundle: false,
    errorHandler: typeof errorHandler === &#x27;function&#x27;
      ? function (err) { // pass along directories as well
        return errorHandler(err, cwd, rootDirName)
      }
      : errorHandler // pass undefined / false / etc
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.cli" id="apidoc.element.budo.cli">
        function <span class="apidocSignatureSpan">budo.</span>cli
        <span class="apidocSignatureSpan">(args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function budoCLI(args, opts) {
  var argv = parseArgs(args, opts)

  // if no stream is specified, default to stdout
  if (argv.stream !== false) {
    argv.stream = /^win/.test(process.platform) ? process.stdout : stdoutStream
  }

  var entries = argv._
  delete argv._

  argv.browserifyArgs = argv[&#x27;--&#x27;]
  delete argv[&#x27;--&#x27;]

  if (argv.version) {
    console.log(&#x27;budo v&#x27; + require(&#x27;./package.json&#x27;).version)
    console.log(&#x27;browserify v&#x27; + require(&#x27;browserify/package.json&#x27;).version)
    console.log(&#x27;watchify v&#x27; + require(&#x27;watchify-middleware&#x27;).getWatchifyVersion())
    return null
  }

  if (argv.help) {
    var help = require(&#x27;path&#x27;).join(__dirname, &#x27;bin&#x27;, &#x27;help.txt&#x27;)
    require(&#x27;fs&#x27;).createReadStream(help)
      .pipe(process.stdout)
    return null
  }

  if (argv.outfile) {
    console.error(color.yellow(&#x27;WARNING&#x27;), &#x27;--outfile has been removed in budo@3.0&#x27;)
  }

  if (typeof argv.port === &#x27;string&#x27;) {
    argv.port = parseInt(argv.port, 10)
  }
  if (typeof argv.livePort === &#x27;string&#x27;) {
    argv.livePort = parseInt(argv.livePort, 10)
  }

  // opts.live can be a glob or a boolean
  if (typeof argv.live === &#x27;string&#x27; &#x26;&#x26; /(true|false)/.test(argv.live)) {
    argv.live = argv.live === &#x27;true&#x27;
  }

  // CLI only option for executing a child process
  var instance = budo(entries, argv).on(&#x27;error&#x27;, exit)
  var onUpdates = [].concat(argv.onupdate).filter(Boolean)
  onUpdates.forEach(function (cmd) {
    instance.on(&#x27;update&#x27;, execFunc(cmd))
  })

  return instance
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.error_handler" id="apidoc.element.budo.error_handler">
        function <span class="apidocSignatureSpan">budo.</span>error_handler
        <span class="apidocSignatureSpan">(err, cwd, rootDirName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function errorHandler(err, cwd, rootDirName) {
  console.error(&#x27;%s&#x27;, err)
  var msgStr = stripAnsi(err.message)
  var params = [
    JSON.stringify(msgStr),
    JSON.stringify(cwd),
    JSON.stringify(rootDirName)
  ].join(&#x27;,&#x27;)
  return &#x27;;(&#x27; + bundleError + &#x27;)(&#x27; + params + &#x27;);&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.file_watch" id="apidoc.element.budo.file_watch">
        function <span class="apidocSignatureSpan">budo.</span>file_watch
        <span class="apidocSignatureSpan">(glob, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file_watch = function (glob, opt) {
  opt = xtend({
    usePolling: opt &#x26;&#x26; opt.poll,
    ignored: ignores,
    ignoreInitial: true
  }, opt)

  var emitter = new Emitter()
  var closed = false
  var ready = false

  var watcher = watch(glob, opt)
  watcher.on(&#x27;add&#x27;, onWatch.bind(null, &#x27;add&#x27;))
  watcher.on(&#x27;change&#x27;, onWatch.bind(null, &#x27;change&#x27;))

  // chokidar@1.0.0-r6 only allows close after ready event
  watcher.once(&#x27;ready&#x27;, function () {
    ready = true
    if (closed) watcher.close()
  })

  function onWatch (event, path) {
    emitter.emit(&#x27;watch&#x27;, event, path)
  }

  emitter.close = function () {
    if (closed) return
    if (ready) watcher.close()
    closed = true
  }
  return emitter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.get_ports" id="apidoc.element.budo.get_ports">
        function <span class="apidocSignatureSpan">budo.</span>get_ports
        <span class="apidocSignatureSpan">(opt, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getServerPorts(opt, cb) {
  opt = xtend({ port: 9966, livePort: 35729 }, opt)

  // try to use exact port specified or the defaults
  if (!opt.portfind) {
    return process.nextTick(function () {
      cb(null, {
        port: opt.port,
        livePort: opt.livePort
      })
    })
  }

  // find our multiple available ports
  getPorts([ opt.port, opt.livePort ], function (err, ports) {
    if (err) return cb(err)
    cb(null, {
      port: ports[0], livePort: ports[1]
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.map_entry" id="apidoc.element.budo.map_entry">
        function <span class="apidocSignatureSpan">budo.</span>map_entry
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapEntry(file) {
  if (file === &#x27;.&#x27;) {
    file = entry()
  }

  var parts
  // absolute path with letter drive, eg C:/
  if (/^[A-Z]:[/\\]+/.test(file)) {
    parts = file.split(/:(?:(?=[^/\\]))/)
  } else {
    parts = file.split(&#x27;:&#x27;)
  }

  var pathFrom, pathUrl

  if (parts.length &#x3e; 1 &#x26;&#x26; parts[1].length &#x3e; 0) {
    pathFrom = parts[0]
    pathUrl = parts[1]

    if (pathFrom === &#x27;.&#x27;) {
      pathFrom = entry()
    }
  } else {
    pathFrom = file
    pathUrl = url.parse(path.basename(pathFrom)).pathname
  }

  return {
    url: pathUrl,
    from: pathFrom
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.middleware" id="apidoc.element.budo.middleware">
        function <span class="apidocSignatureSpan">budo.</span>middleware
        <span class="apidocSignatureSpan">(entryMiddleware, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function budoMiddleware(entryMiddleware, opts) {
  opts = opts || {}
  var staticPaths = [].concat(opts.dir).filter(Boolean)
  if (staticPaths.length === 0) {
    staticPaths = [ process.cwd() ]
  }

  var entrySrc = opts.serve
  var live = opts.live
  var cors = opts.cors
  var handler = stacked()
  var middlewares = [].concat(opts.middleware).filter(Boolean)

  // Everything is logged except favicon.ico
  var logHandler = logger({
    ignore: [ &#x27;/favicon.ico&#x27; ]
  })
  handler.use(function (req, res, next) {
    if (cors) {
      res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With
&#x27;)
      res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;GET, PUT, POST&#x27;)
      res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)
    }
    logHandler(req, res, next)
  })

  // User middleware(s) can override others
  middlewares.forEach(function (middleware) {
    if (typeof middleware !== &#x27;function&#x27;) {
      throw new Error(&#x27;middleware options must be functions&#x27;)
    }
    handler.use(function (req, res, next) {
      logHandler.type = &#x27;middleware&#x27;
      middleware(req, res, next)
    })
  })

  // Re-route for pushState support
  if (opts.pushstate) handler.use(pushState())

  // Inject liveReload snippet on response
  var liveInjector = liveReload()
  handler.use(function (req, res, next) {
    if (!live || live.plugin) return next()
    if (live.host) liveInjector.host = live.host
    if (live.port) liveInjector.port = live.port
    liveInjector(req, res, next)
  })

  // Entry (watchify) middleware
  if (entryMiddleware) {
    var entryRoute = &#x27;/&#x27; + urlLib.parse(entrySrc).pathname
    handler.use(function (req, res, next) {
      if (urlTrim(req.url) === urlTrim(entryRoute)) {
        entryMiddleware(req, res, next)
      } else {
        next()
      }
    })
  }

  // Ignore favicon clutter
  handler.mount(&#x27;/favicon.ico&#x27;, favicon)

  // If the user wishes to *always* serve
  // a generated index instead of a static one.
  if (opts.forceDefaultIndex) {
    handler.use(indexHandler)
  }

  // Static assets (html/images/etc)
  staticPaths.forEach(function (rootFile) {
    var staticHandler = serveStatic(rootFile, {
      cacheControl: false
    })
    handler.use(function (req, res, next) {
      logHandler.type = &#x27;static&#x27;
      staticHandler(req, res, next)
    })
  })

  // Generates a default index.html
  // when none is found locally.
  handler.use(indexHandler)

  // Handle errors
  handler.use(function (req, res) {
    res.statusCode = 404
    res.end(&#x27;404 not found: &#x27; + escapeHtml(req.url))
  })

  // Allow live options to be changed at runtime
  handler.setLiveOptions = setLiveOptions
  return handler

  function setLiveOptions (opts) {
    live = opts
  }

  function favicon (req, res) {
    var maxAge = 345600 // 4 days
    res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public, max-age=&#x27; + Math.floor(maxAge / 1000))
    res.setHeader(&#x27;Content-Type&#x27;, &#x27;image/x-icon&#x27;)
    res.statusCode = 200
    res.end()
  }

  function indexHandler (req, res, next) {
    if (urlLib.parse(req.url).pathname === &#x27;/&#x27; || /\/index.html?/i.test(req.url)) {
      // If we reach this, our response will be generated
      // (not static from local file system)
      logHandler.type = &#x27;generated&#x27;
      res.setHeader(&#x27;content-type&#x27;, &#x27;text/html&#x27;)

      var stream = opts.defaultIndex || defaultIndex
      stream({
        entry: entrySrc,
        title: opts.title,
        css: opts.css,
        base: opts.base === true ? &#x27;/&#x27; : (opts.base || null)
      }).pipe(res)
    } else {
      next()
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.parse_args" id="apidoc.element.budo.parse_args">
        function <span class="apidocSignatureSpan">budo.</span>parse_args
        <span class="apidocSignatureSpan">(args, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseArgs(args, opt) {
  var argv = minimist(args, {
    boolean: [
      &#x27;stream&#x27;,
      &#x27;debug&#x27;,
      &#x27;errorHandler&#x27;,
      &#x27;forceDefaultIndex&#x27;,
      &#x27;open&#x27;,
      &#x27;portfind&#x27;,
      &#x27;pushstate&#x27;,
      &#x27;ndjson&#x27;,
      &#x27;verbose&#x27;,
      &#x27;cors&#x27;,
      &#x27;ssl&#x27;
    ],
    string: [
      &#x27;host&#x27;,
      &#x27;port&#x27;,
      &#x27;dir&#x27;,
      &#x27;onupdate&#x27;,
      &#x27;serve&#x27;,
      &#x27;title&#x27;,
      &#x27;watchGlob&#x27;,
      &#x27;cert&#x27;,
      &#x27;key&#x27;
    ],
    default: module.exports.defaults,
    alias: {
      port: &#x27;p&#x27;,
      ssl: &#x27;S&#x27;,
      serve: &#x27;s&#x27;,
      cert: &#x27;C&#x27;,
      key: &#x27;K&#x27;,
      verbose: &#x27;v&#x27;,
      help: &#x27;h&#x27;,
      host: &#x27;H&#x27;,
      dir: &#x27;d&#x27;,
      live: &#x27;l&#x27;,
      open: &#x27;o&#x27;,
      watchGlob: [ &#x27;wg&#x27;, &#x27;watch-glob&#x27; ],
      errorHandler: &#x27;error-handler&#x27;,
      forceDefaultIndex: &#x27;force-default-index&#x27;,
      &#x27;live-port&#x27;: [&#x27;L&#x27;, &#x27;livePort&#x27;],
      pushstate: &#x27;P&#x27;
    },
    &#x27;--&#x27;: true
  })
  return xtend(argv, opt)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.server" id="apidoc.element.budo.server">
        function <span class="apidocSignatureSpan">budo.</span>server
        <span class="apidocSignatureSpan">(entryMiddleware, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(entryMiddleware, opts, cb) {
  var handler = createMiddleware(entryMiddleware, opts)
  var ssl = opts.ssl

  if (ssl &#x26;&#x26; (!opts.cert &#x26;&#x26; opts.key) || (!opts.key &#x26;&#x26; opts.cert)) {
    throw new TypeError(&#x27;If you specify a cert, you must specify a key and vice versa.\n&#x27; +
        &#x27;Or, you can omit the &#x22;cert&#x22; and &#x22;key&#x22; options to generate a new self-signed certificate.&#x27;)
  }

  if (opts.ssl) {
    if (opts.cert &#x26;&#x26; opts.key) {
      // user specified their own cert/key pair
      create({
        cert: fs.readFileSync(opts.cert),
        key: fs.readFileSync(opts.key)
      })
    } else {
      // generate a self-signed cert
      pem.createCertificate({ days: 1, selfSigned: true }, function (err, keys) {
        if (err) return cb(err)
        create({
          key: keys.serviceKey,
          cert: keys.certificate
        })
      })
    }
  } else {
    // no HTTPS, handle normally
    create()
  }

  function create (httpsOpts) {
    var server = ssl
      ? https.createServer(httpsOpts, handler)
      : http.createServer(handler)
    server.setLiveOptions = handler.setLiveOptions

    // TODO: Perhaps --ssl should support some sort of HTTP -&#x3e; HTTPS redirect
    process.nextTick(function () {
      cb(null, server, httpsOpts)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.simple_http_logger" id="apidoc.element.budo.simple_http_logger">
        function <span class="apidocSignatureSpan">budo.</span>simple_http_logger
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function simpleHttpLoggerMiddleware(opts) {
  opts = opts || {}
  var ignores = [].concat(opts.ignore).filter(Boolean)

  var httpLogger = function simpleHttpLogger (req, res, next) {
    if (ignores.indexOf(req.url) &#x3e;= 0) return next()
    if (!req.url) return next()

    // request data
    req._startAt = undefined

    // response data
    res._startAt = undefined

    // record request start
    recordStartTime.call(req)

    var byteLength = 0
    var logRequest = function () {
      if (!req._startAt || !res._startAt) {
        // missing request and/or response start time
        return
      }

      // calculate diff
      var ms = (res._startAt[0] - req._startAt[0]) * 1000 +
        (res._startAt[1] - req._startAt[1]) * 1e-6

      log.info({
        elapsed: ms,
        contentLength: byteLength,
        method: (req.method || &#x27;GET&#x27;).toUpperCase(),
        url: req.url,
        statusCode: res.statusCode,
        type: httpLogger.type === &#x27;static&#x27; ? undefined : httpLogger.type,
        colors: {
          elapsed: ms &#x3e; 1000 ? &#x27;yellow&#x27; : &#x27;dim&#x27;
        }
      })
    }

    var isAlreadyLogging = res._simpleHttpLogger
    res._simpleHttpLogger = true

    if (!isAlreadyLogging) {
      // record response start
      onResHeaders(res, recordStartTime)

      // log when response finished
      onResFinished(res, logRequest)

      var writeFn = res.write

      // catch content-length of payload
      res.write = function (payload) {
        if (payload) byteLength += payload.length
        return writeFn.apply(res, arguments)
      }
    }

    next()
  }

  httpLogger.type = &#x27;static&#x27;
  return httpLogger
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.tinylr" id="apidoc.element.budo.tinylr">
        function <span class="apidocSignatureSpan">budo.</span>tinylr
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tinylr = function (opt) {
  opt = xtend(opt)
  if (typeof opt.port !== &#x27;number&#x27;) {
    opt.port = 35729
  }

  var server = tinylr({
    cert: opt.cert,
    key: opt.key
  })
  var closed = false
  var ready = false

  server.listen(opt.port, opt.host || undefined, function () {
    ready = true
    if (closed) return server.close()
    log.info({ message: &#x27;LiveReload running on &#x27; + opt.port })
  })

  var serverImpl = server.server
  serverImpl.removeAllListeners(&#x27;error&#x27;)
  serverImpl.on(&#x27;error&#x27;, function (err) {
    if (err.code === &#x27;EADDRINUSE&#x27;) {
      process.stderr.write(&#x27;ERROR: livereload not started, port &#x27; + opt.port + &#x27; is in use\n&#x27;)
    } else {
      process.stderr.write((err.stack ? err.stack : err) + &#x27;\n&#x27;)
    }
    close()
  })

  function close () {
    if (closed) return
    if (ready) server.close()
    closed = true
  }

  return {
    close: close,

    reload: function reload (path) {
      try {
        server.changed({
          body: {
            files: path ? [ path ] : &#x27;*&#x27;
          }
        })
      } catch (e) {
        throw e
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.toString" id="apidoc.element.budo.toString">
        function <span class="apidocSignatureSpan">budo.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.bundler" id="apidoc.module.budo.bundler">module budo.bundler</a></h1>


    <h2>
        <a href="#apidoc.element.budo.bundler.bundler" id="apidoc.element.budo.bundler.bundler">
        function <span class="apidocSignatureSpan">budo.</span>bundler
        <span class="apidocSignatureSpan">(files, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBundler(files, opts) {
  var bOpts = xtend({
    cache: {},
    packageCache: {},
    debug: opts.debug
  }, opts.browserify)

  var bundler
  var args = opts.browserifyArgs
  if (args &#x26;&#x26; Array.isArray(args)) {
    // CLI args for browserify
    bundler = fromArgs(args, bOpts)
  } else {
    // just assume JS only options
    bundler = browserify(bOpts)
  }

  files.forEach(function (file) {
    bundler.add(path.resolve(file))
  })

  var errorHandler = opts.errorHandler
  if (typeof errorHandler !== &#x27;function&#x27; &#x26;&#x26; errorHandler !== false) {
    errorHandler = defaultErrorHandler
  }

  var cwd = opts.cwd
  var rootDirName
  if (cwd) {
    cwd = path.normalize(cwd)
    rootDirName = path.basename(cwd) + path.sep
  }
  return createMiddleware(bundler, {
    delay: opts.delay || 0,
    initialBundle: false,
    errorHandler: typeof errorHandler === &#x27;function&#x27;
      ? function (err) { // pass along directories as well
        return errorHandler(err, cwd, rootDirName)
      }
      : errorHandler // pass undefined / false / etc
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.cli" id="apidoc.module.budo.cli">module budo.cli</a></h1>


    <h2>
        <a href="#apidoc.element.budo.cli.cli" id="apidoc.element.budo.cli.cli">
        function <span class="apidocSignatureSpan">budo.</span>cli
        <span class="apidocSignatureSpan">(args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function budoCLI(args, opts) {
  var argv = parseArgs(args, opts)

  // if no stream is specified, default to stdout
  if (argv.stream !== false) {
    argv.stream = /^win/.test(process.platform) ? process.stdout : stdoutStream
  }

  var entries = argv._
  delete argv._

  argv.browserifyArgs = argv[&#x27;--&#x27;]
  delete argv[&#x27;--&#x27;]

  if (argv.version) {
    console.log(&#x27;budo v&#x27; + require(&#x27;./package.json&#x27;).version)
    console.log(&#x27;browserify v&#x27; + require(&#x27;browserify/package.json&#x27;).version)
    console.log(&#x27;watchify v&#x27; + require(&#x27;watchify-middleware&#x27;).getWatchifyVersion())
    return null
  }

  if (argv.help) {
    var help = require(&#x27;path&#x27;).join(__dirname, &#x27;bin&#x27;, &#x27;help.txt&#x27;)
    require(&#x27;fs&#x27;).createReadStream(help)
      .pipe(process.stdout)
    return null
  }

  if (argv.outfile) {
    console.error(color.yellow(&#x27;WARNING&#x27;), &#x27;--outfile has been removed in budo@3.0&#x27;)
  }

  if (typeof argv.port === &#x27;string&#x27;) {
    argv.port = parseInt(argv.port, 10)
  }
  if (typeof argv.livePort === &#x27;string&#x27;) {
    argv.livePort = parseInt(argv.livePort, 10)
  }

  // opts.live can be a glob or a boolean
  if (typeof argv.live === &#x27;string&#x27; &#x26;&#x26; /(true|false)/.test(argv.live)) {
    argv.live = argv.live === &#x27;true&#x27;
  }

  // CLI only option for executing a child process
  var instance = budo(entries, argv).on(&#x27;error&#x27;, exit)
  var onUpdates = [].concat(argv.onupdate).filter(Boolean)
  onUpdates.forEach(function (cmd) {
    instance.on(&#x27;update&#x27;, execFunc(cmd))
  })

  return instance
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.error_handler" id="apidoc.module.budo.error_handler">module budo.error_handler</a></h1>


    <h2>
        <a href="#apidoc.element.budo.error_handler.error_handler" id="apidoc.element.budo.error_handler.error_handler">
        function <span class="apidocSignatureSpan">budo.</span>error_handler
        <span class="apidocSignatureSpan">(err, cwd, rootDirName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function errorHandler(err, cwd, rootDirName) {
  console.error(&#x27;%s&#x27;, err)
  var msgStr = stripAnsi(err.message)
  var params = [
    JSON.stringify(msgStr),
    JSON.stringify(cwd),
    JSON.stringify(rootDirName)
  ].join(&#x27;,&#x27;)
  return &#x27;;(&#x27; + bundleError + &#x27;)(&#x27; + params + &#x27;);&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.error_handler.render" id="apidoc.element.budo.error_handler.render">
        function <span class="apidocSignatureSpan">budo.error_handler.</span>render
        <span class="apidocSignatureSpan">(message, cwd, rootDirName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bundleError(message, cwd, rootDirName) {
  // Everything has to be contained inside this function
  // for it to get stringified correctly. i.e. no require()!
  console.error(message)

  if (typeof document === &#x27;undefined&#x27;) {
    return
  } else if (!document.body) {
    document.addEventListener(&#x27;DOMContentLoaded&#x27;, createErrorBox)
  } else {
    createErrorBox()
  }

  function createErrorBox () {
    var parsed = parseError(message)

    var overlayBox = document.createElement(&#x27;div&#x27;)
    css(overlayBox, {
      position: &#x27;fixed&#x27;,
      width: &#x27;100%&#x27;,
      height: &#x27;100%&#x27;,
      zIndex: &#x27;100000000&#x27;,
      top: &#x27;0&#x27;,
      left: &#x27;0&#x27;,
      padding: &#x27;20px&#x27;,
      margin: &#x27;0px&#x27;,
      &#x27;box-sizing&#x27;: &#x27;border-box&#x27;,
      background: &#x27;#fff&#x27;,
      display: &#x27;block&#x27;,
      &#x27;font-size&#x27;: &#x27;14px&#x27;,
      &#x27;font-weight&#x27;: &#x27;normal&#x27;,
      &#x27;font-family&#x27;: &#x27;monospace&#x27;
    })

    if (!parsed.format) {
      var pre = document.createElement(&#x27;pre&#x27;)
      pre.textContent = message
      css(pre, {
        &#x27;word-wrap&#x27;: &#x27;break-word&#x27;,
        &#x27;white-space&#x27;: &#x27;pre-wrap&#x27;,
        &#x27;box-sizing&#x27;: &#x27;border-box&#x27;,
        margin: &#x27;0&#x27;,
        color: &#x27;#ff0000&#x27;
      })
      overlayBox.appendChild(pre)
    } else {
      var commonElements = []

      var messageDiv = document.createElement(&#x27;div&#x27;)
      commonElements.push(messageDiv)
      messageDiv.textContent = parsed.message
      overlayBox.appendChild(messageDiv)
      css(messageDiv, {
        color: &#x27;#ff2e2e&#x27;,
        &#x27;font-size&#x27;: &#x27;16px&#x27;
      })

      var pathLocContainer = document.createElement(&#x27;div&#x27;)
      css(pathLocContainer, { &#x27;padding-top&#x27;: &#x27;10px&#x27; })

      if (isFinite(parsed.line)) {
        var location = document.createElement(&#x27;div&#x27;)
        commonElements.push(location)
        var colStr = isFinite(parsed.column) ? (&#x27;, column &#x27; + parsed.column) : &#x27;&#x27;
        location.textContent = (&#x27;line &#x27; + parsed.line + colStr).trim()
        css(location, {
          color: &#x27;hsl(0, 0%, 50%)&#x27;,
          &#x27;padding-bottom&#x27;: &#x27;0px&#x27;,
          &#x27;font-size&#x27;: &#x27;12px&#x27;,
          &#x27;font-weight&#x27;: &#x27;bold&#x27;
        })
        pathLocContainer.appendChild(location)
      }

      var path = document.createElement(&#x27;div&#x27;)
      path.textContent = trimPath(parsed.path)
      commonElements.push(path)
      css(path, { &#x27;font-style&#x27;: &#x27;italic&#x27; })
      pathLocContainer.appendChild(path)
      overlayBox.appendChild(pathLocContainer)

      if (parsed.code) {
        var sourceContainer = document.createElement(&#x27;div&#x27;)
        var source = document.createElement(&#x27;div&#x27;)
        var hr = document.createElement(&#x27;div&#x27;)
        css(hr, {
          background: &#x27;hsl(0, 0%, 90%)&#x27;,
          width: &#x27;100%&#x27;,
          height: &#x27;2px&#x27;,
          padding: &#x27;0&#x27;,
          &#x27;margin-bottom&#x27;: &#x27;10px&#x27;,
          &#x27;margin-top&#x27;: &#x27;10px&#x27;
        })
        commonElements.push(source)
        source.textContent = parsed.code
        css(source, {
          color: &#x27;black&#x27;,
          &#x27;font-weight&#x27;: &#x27;bold&#x27;,
          &#x27;font-size&#x27;: &#x27;14px&#x27;,
          &#x27;padding-left&#x27;: &#x27;0px&#x27;
        })

        sourceContainer.appendChild(hr)
        sourceContainer.appendChild(source)
        overlayBox.appendChild(sourceContainer)
      }

      // apply common styles
      commonElements.forEach(function (e) {
        css(e, {
          &#x27;word-wrap&#x27;: &#x27;break-word&#x27;,
          &#x27;white-space&#x27;: &#x27;pre-wrap&#x27;,
          &#x27;box-sizing&#x27;: &#x27;border-box&#x27;,
          display: &#x27;block&#x27;,
          margin: &#x27;0&#x27;,
          &#x27;vertical-align&#x27;: &#x27;bottom&#x27;
        })
      })
    }
    document.body.appendChild(overlayBox)
  }

  function trimPath (filePath) {
    if (filePath.indexOf(cwd) === 0) {
      filePath = rootDirName + filePath.substring(cwd.length + 1)
    }
    return filePath
  }

  function css (element, style) {
    Object.keys(style).forEach(function (k) {
      element.style[k] = style[k]
    })
  }

  // parse an error message into pieces
  function parseError (err) {
    var filePath, lineNum, splitLines
    var result = {}

    // For root files that syntax-error doesn&#x27;t pick up:
    var parseFilePrefix = &#x27;Parsing file &#x27;
    if (err.indexOf(parseFilePrefix) === 0) {
      var pathWi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.file_watch" id="apidoc.module.budo.file_watch">module budo.file_watch</a></h1>


    <h2>
        <a href="#apidoc.element.budo.file_watch.file_watch" id="apidoc.element.budo.file_watch.file_watch">
        function <span class="apidocSignatureSpan">budo.</span>file_watch
        <span class="apidocSignatureSpan">(glob, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file_watch = function (glob, opt) {
  opt = xtend({
    usePolling: opt &#x26;&#x26; opt.poll,
    ignored: ignores,
    ignoreInitial: true
  }, opt)

  var emitter = new Emitter()
  var closed = false
  var ready = false

  var watcher = watch(glob, opt)
  watcher.on(&#x27;add&#x27;, onWatch.bind(null, &#x27;add&#x27;))
  watcher.on(&#x27;change&#x27;, onWatch.bind(null, &#x27;change&#x27;))

  // chokidar@1.0.0-r6 only allows close after ready event
  watcher.once(&#x27;ready&#x27;, function () {
    ready = true
    if (closed) watcher.close()
  })

  function onWatch (event, path) {
    emitter.emit(&#x27;watch&#x27;, event, path)
  }

  emitter.close = function () {
    if (closed) return
    if (ready) watcher.close()
    closed = true
  }
  return emitter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.get_ports" id="apidoc.module.budo.get_ports">module budo.get_ports</a></h1>


    <h2>
        <a href="#apidoc.element.budo.get_ports.get_ports" id="apidoc.element.budo.get_ports.get_ports">
        function <span class="apidocSignatureSpan">budo.</span>get_ports
        <span class="apidocSignatureSpan">(opt, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getServerPorts(opt, cb) {
  opt = xtend({ port: 9966, livePort: 35729 }, opt)

  // try to use exact port specified or the defaults
  if (!opt.portfind) {
    return process.nextTick(function () {
      cb(null, {
        port: opt.port,
        livePort: opt.livePort
      })
    })
  }

  // find our multiple available ports
  getPorts([ opt.port, opt.livePort ], function (err, ports) {
    if (err) return cb(err)
    cb(null, {
      port: ports[0], livePort: ports[1]
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.map_entry" id="apidoc.module.budo.map_entry">module budo.map_entry</a></h1>


    <h2>
        <a href="#apidoc.element.budo.map_entry.map_entry" id="apidoc.element.budo.map_entry.map_entry">
        function <span class="apidocSignatureSpan">budo.</span>map_entry
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapEntry(file) {
  if (file === &#x27;.&#x27;) {
    file = entry()
  }

  var parts
  // absolute path with letter drive, eg C:/
  if (/^[A-Z]:[/\\]+/.test(file)) {
    parts = file.split(/:(?:(?=[^/\\]))/)
  } else {
    parts = file.split(&#x27;:&#x27;)
  }

  var pathFrom, pathUrl

  if (parts.length &#x3e; 1 &#x26;&#x26; parts[1].length &#x3e; 0) {
    pathFrom = parts[0]
    pathUrl = parts[1]

    if (pathFrom === &#x27;.&#x27;) {
      pathFrom = entry()
    }
  } else {
    pathFrom = file
    pathUrl = url.parse(path.basename(pathFrom)).pathname
  }

  return {
    url: pathUrl,
    from: pathFrom
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.middleware" id="apidoc.module.budo.middleware">module budo.middleware</a></h1>


    <h2>
        <a href="#apidoc.element.budo.middleware.middleware" id="apidoc.element.budo.middleware.middleware">
        function <span class="apidocSignatureSpan">budo.</span>middleware
        <span class="apidocSignatureSpan">(entryMiddleware, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function budoMiddleware(entryMiddleware, opts) {
  opts = opts || {}
  var staticPaths = [].concat(opts.dir).filter(Boolean)
  if (staticPaths.length === 0) {
    staticPaths = [ process.cwd() ]
  }

  var entrySrc = opts.serve
  var live = opts.live
  var cors = opts.cors
  var handler = stacked()
  var middlewares = [].concat(opts.middleware).filter(Boolean)

  // Everything is logged except favicon.ico
  var logHandler = logger({
    ignore: [ &#x27;/favicon.ico&#x27; ]
  })
  handler.use(function (req, res, next) {
    if (cors) {
      res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With
&#x27;)
      res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;GET, PUT, POST&#x27;)
      res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)
    }
    logHandler(req, res, next)
  })

  // User middleware(s) can override others
  middlewares.forEach(function (middleware) {
    if (typeof middleware !== &#x27;function&#x27;) {
      throw new Error(&#x27;middleware options must be functions&#x27;)
    }
    handler.use(function (req, res, next) {
      logHandler.type = &#x27;middleware&#x27;
      middleware(req, res, next)
    })
  })

  // Re-route for pushState support
  if (opts.pushstate) handler.use(pushState())

  // Inject liveReload snippet on response
  var liveInjector = liveReload()
  handler.use(function (req, res, next) {
    if (!live || live.plugin) return next()
    if (live.host) liveInjector.host = live.host
    if (live.port) liveInjector.port = live.port
    liveInjector(req, res, next)
  })

  // Entry (watchify) middleware
  if (entryMiddleware) {
    var entryRoute = &#x27;/&#x27; + urlLib.parse(entrySrc).pathname
    handler.use(function (req, res, next) {
      if (urlTrim(req.url) === urlTrim(entryRoute)) {
        entryMiddleware(req, res, next)
      } else {
        next()
      }
    })
  }

  // Ignore favicon clutter
  handler.mount(&#x27;/favicon.ico&#x27;, favicon)

  // If the user wishes to *always* serve
  // a generated index instead of a static one.
  if (opts.forceDefaultIndex) {
    handler.use(indexHandler)
  }

  // Static assets (html/images/etc)
  staticPaths.forEach(function (rootFile) {
    var staticHandler = serveStatic(rootFile, {
      cacheControl: false
    })
    handler.use(function (req, res, next) {
      logHandler.type = &#x27;static&#x27;
      staticHandler(req, res, next)
    })
  })

  // Generates a default index.html
  // when none is found locally.
  handler.use(indexHandler)

  // Handle errors
  handler.use(function (req, res) {
    res.statusCode = 404
    res.end(&#x27;404 not found: &#x27; + escapeHtml(req.url))
  })

  // Allow live options to be changed at runtime
  handler.setLiveOptions = setLiveOptions
  return handler

  function setLiveOptions (opts) {
    live = opts
  }

  function favicon (req, res) {
    var maxAge = 345600 // 4 days
    res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public, max-age=&#x27; + Math.floor(maxAge / 1000))
    res.setHeader(&#x27;Content-Type&#x27;, &#x27;image/x-icon&#x27;)
    res.statusCode = 200
    res.end()
  }

  function indexHandler (req, res, next) {
    if (urlLib.parse(req.url).pathname === &#x27;/&#x27; || /\/index.html?/i.test(req.url)) {
      // If we reach this, our response will be generated
      // (not static from local file system)
      logHandler.type = &#x27;generated&#x27;
      res.setHeader(&#x27;content-type&#x27;, &#x27;text/html&#x27;)

      var stream = opts.defaultIndex || defaultIndex
      stream({
        entry: entrySrc,
        title: opts.title,
        css: opts.css,
        base: opts.base === true ? &#x27;/&#x27; : (opts.base || null)
      }).pipe(res)
    } else {
      next()
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.parse_args" id="apidoc.module.budo.parse_args">module budo.parse_args</a></h1>


    <h2>
        <a href="#apidoc.element.budo.parse_args.parse_args" id="apidoc.element.budo.parse_args.parse_args">
        function <span class="apidocSignatureSpan">budo.</span>parse_args
        <span class="apidocSignatureSpan">(args, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseArgs(args, opt) {
  var argv = minimist(args, {
    boolean: [
      &#x27;stream&#x27;,
      &#x27;debug&#x27;,
      &#x27;errorHandler&#x27;,
      &#x27;forceDefaultIndex&#x27;,
      &#x27;open&#x27;,
      &#x27;portfind&#x27;,
      &#x27;pushstate&#x27;,
      &#x27;ndjson&#x27;,
      &#x27;verbose&#x27;,
      &#x27;cors&#x27;,
      &#x27;ssl&#x27;
    ],
    string: [
      &#x27;host&#x27;,
      &#x27;port&#x27;,
      &#x27;dir&#x27;,
      &#x27;onupdate&#x27;,
      &#x27;serve&#x27;,
      &#x27;title&#x27;,
      &#x27;watchGlob&#x27;,
      &#x27;cert&#x27;,
      &#x27;key&#x27;
    ],
    default: module.exports.defaults,
    alias: {
      port: &#x27;p&#x27;,
      ssl: &#x27;S&#x27;,
      serve: &#x27;s&#x27;,
      cert: &#x27;C&#x27;,
      key: &#x27;K&#x27;,
      verbose: &#x27;v&#x27;,
      help: &#x27;h&#x27;,
      host: &#x27;H&#x27;,
      dir: &#x27;d&#x27;,
      live: &#x27;l&#x27;,
      open: &#x27;o&#x27;,
      watchGlob: [ &#x27;wg&#x27;, &#x27;watch-glob&#x27; ],
      errorHandler: &#x27;error-handler&#x27;,
      forceDefaultIndex: &#x27;force-default-index&#x27;,
      &#x27;live-port&#x27;: [&#x27;L&#x27;, &#x27;livePort&#x27;],
      pushstate: &#x27;P&#x27;
    },
    &#x27;--&#x27;: true
  })
  return xtend(argv, opt)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.server" id="apidoc.module.budo.server">module budo.server</a></h1>


    <h2>
        <a href="#apidoc.element.budo.server.server" id="apidoc.element.budo.server.server">
        function <span class="apidocSignatureSpan">budo.</span>server
        <span class="apidocSignatureSpan">(entryMiddleware, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(entryMiddleware, opts, cb) {
  var handler = createMiddleware(entryMiddleware, opts)
  var ssl = opts.ssl

  if (ssl &#x26;&#x26; (!opts.cert &#x26;&#x26; opts.key) || (!opts.key &#x26;&#x26; opts.cert)) {
    throw new TypeError(&#x27;If you specify a cert, you must specify a key and vice versa.\n&#x27; +
        &#x27;Or, you can omit the &#x22;cert&#x22; and &#x22;key&#x22; options to generate a new self-signed certificate.&#x27;)
  }

  if (opts.ssl) {
    if (opts.cert &#x26;&#x26; opts.key) {
      // user specified their own cert/key pair
      create({
        cert: fs.readFileSync(opts.cert),
        key: fs.readFileSync(opts.key)
      })
    } else {
      // generate a self-signed cert
      pem.createCertificate({ days: 1, selfSigned: true }, function (err, keys) {
        if (err) return cb(err)
        create({
          key: keys.serviceKey,
          cert: keys.certificate
        })
      })
    }
  } else {
    // no HTTPS, handle normally
    create()
  }

  function create (httpsOpts) {
    var server = ssl
      ? https.createServer(httpsOpts, handler)
      : http.createServer(handler)
    server.setLiveOptions = handler.setLiveOptions

    // TODO: Perhaps --ssl should support some sort of HTTP -&#x3e; HTTPS redirect
    process.nextTick(function () {
      cb(null, server, httpsOpts)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.simple_http_logger" id="apidoc.module.budo.simple_http_logger">module budo.simple_http_logger</a></h1>


    <h2>
        <a href="#apidoc.element.budo.simple_http_logger.simple_http_logger" id="apidoc.element.budo.simple_http_logger.simple_http_logger">
        function <span class="apidocSignatureSpan">budo.</span>simple_http_logger
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function simpleHttpLoggerMiddleware(opts) {
  opts = opts || {}
  var ignores = [].concat(opts.ignore).filter(Boolean)

  var httpLogger = function simpleHttpLogger (req, res, next) {
    if (ignores.indexOf(req.url) &#x3e;= 0) return next()
    if (!req.url) return next()

    // request data
    req._startAt = undefined

    // response data
    res._startAt = undefined

    // record request start
    recordStartTime.call(req)

    var byteLength = 0
    var logRequest = function () {
      if (!req._startAt || !res._startAt) {
        // missing request and/or response start time
        return
      }

      // calculate diff
      var ms = (res._startAt[0] - req._startAt[0]) * 1000 +
        (res._startAt[1] - req._startAt[1]) * 1e-6

      log.info({
        elapsed: ms,
        contentLength: byteLength,
        method: (req.method || &#x27;GET&#x27;).toUpperCase(),
        url: req.url,
        statusCode: res.statusCode,
        type: httpLogger.type === &#x27;static&#x27; ? undefined : httpLogger.type,
        colors: {
          elapsed: ms &#x3e; 1000 ? &#x27;yellow&#x27; : &#x27;dim&#x27;
        }
      })
    }

    var isAlreadyLogging = res._simpleHttpLogger
    res._simpleHttpLogger = true

    if (!isAlreadyLogging) {
      // record response start
      onResHeaders(res, recordStartTime)

      // log when response finished
      onResFinished(res, logRequest)

      var writeFn = res.write

      // catch content-length of payload
      res.write = function (payload) {
        if (payload) byteLength += payload.length
        return writeFn.apply(res, arguments)
      }
    }

    next()
  }

  httpLogger.type = &#x27;static&#x27;
  return httpLogger
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.tinylr" id="apidoc.module.budo.tinylr">module budo.tinylr</a></h1>


    <h2>
        <a href="#apidoc.element.budo.tinylr.tinylr" id="apidoc.element.budo.tinylr.tinylr">
        function <span class="apidocSignatureSpan">budo.</span>tinylr
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tinylr = function (opt) {
  opt = xtend(opt)
  if (typeof opt.port !== &#x27;number&#x27;) {
    opt.port = 35729
  }

  var server = tinylr({
    cert: opt.cert,
    key: opt.key
  })
  var closed = false
  var ready = false

  server.listen(opt.port, opt.host || undefined, function () {
    ready = true
    if (closed) return server.close()
    log.info({ message: &#x27;LiveReload running on &#x27; + opt.port })
  })

  var serverImpl = server.server
  serverImpl.removeAllListeners(&#x27;error&#x27;)
  serverImpl.on(&#x27;error&#x27;, function (err) {
    if (err.code === &#x27;EADDRINUSE&#x27;) {
      process.stderr.write(&#x27;ERROR: livereload not started, port &#x27; + opt.port + &#x27; is in use\n&#x27;)
    } else {
      process.stderr.write((err.stack ? err.stack : err) + &#x27;\n&#x27;)
    }
    close()
  })

  function close () {
    if (closed) return
    if (ready) server.close()
    closed = true
  }

  return {
    close: close,

    reload: function reload (path) {
      try {
        server.changed({
          body: {
            files: path ? [ path ] : &#x27;*&#x27;
          }
        })
      } catch (e) {
        throw e
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.toString" id="apidoc.module.budo.toString">module budo.toString</a></h1>


    <h2>
        <a href="#apidoc.element.budo.toString.toString" id="apidoc.element.budo.toString.toString">
        function <span class="apidocSignatureSpan">budo.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
