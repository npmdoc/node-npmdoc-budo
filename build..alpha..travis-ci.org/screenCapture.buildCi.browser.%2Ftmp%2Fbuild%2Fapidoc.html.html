<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/mattdesl/budo">budo (v9.4.7)</a>
</h1>
<h4>a browserify server for rapid prototyping</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo">module budo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.budo">
            function <span class="apidocSignatureSpan"></span>budo
            <span class="apidocSignatureSpan">(entries, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.bundler">
            function <span class="apidocSignatureSpan">budo.</span>bundler
            <span class="apidocSignatureSpan">(files, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.cli">
            function <span class="apidocSignatureSpan">budo.</span>cli
            <span class="apidocSignatureSpan">(args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.error_handler">
            function <span class="apidocSignatureSpan">budo.</span>error_handler
            <span class="apidocSignatureSpan">(err, cwd, rootDirName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.file_watch">
            function <span class="apidocSignatureSpan">budo.</span>file_watch
            <span class="apidocSignatureSpan">(glob, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.get_ports">
            function <span class="apidocSignatureSpan">budo.</span>get_ports
            <span class="apidocSignatureSpan">(opt, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.map_entry">
            function <span class="apidocSignatureSpan">budo.</span>map_entry
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.middleware">
            function <span class="apidocSignatureSpan">budo.</span>middleware
            <span class="apidocSignatureSpan">(entryMiddleware, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.parse_args">
            function <span class="apidocSignatureSpan">budo.</span>parse_args
            <span class="apidocSignatureSpan">(args, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.server">
            function <span class="apidocSignatureSpan">budo.</span>server
            <span class="apidocSignatureSpan">(entryMiddleware, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.simple_http_logger">
            function <span class="apidocSignatureSpan">budo.</span>simple_http_logger
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.tinylr">
            function <span class="apidocSignatureSpan">budo.</span>tinylr
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.toString">
            function <span class="apidocSignatureSpan">budo.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.bundler">module budo.bundler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.bundler.bundler">
            function <span class="apidocSignatureSpan">budo.</span>bundler
            <span class="apidocSignatureSpan">(files, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.cli">module budo.cli</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.cli.cli">
            function <span class="apidocSignatureSpan">budo.</span>cli
            <span class="apidocSignatureSpan">(args, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.error_handler">module budo.error_handler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.error_handler.error_handler">
            function <span class="apidocSignatureSpan">budo.</span>error_handler
            <span class="apidocSignatureSpan">(err, cwd, rootDirName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.error_handler.render">
            function <span class="apidocSignatureSpan">budo.error_handler.</span>render
            <span class="apidocSignatureSpan">(message, cwd, rootDirName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.file_watch">module budo.file_watch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.file_watch.file_watch">
            function <span class="apidocSignatureSpan">budo.</span>file_watch
            <span class="apidocSignatureSpan">(glob, opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">budo.file_watch.</span>ignores</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.get_ports">module budo.get_ports</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.get_ports.get_ports">
            function <span class="apidocSignatureSpan">budo.</span>get_ports
            <span class="apidocSignatureSpan">(opt, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.map_entry">module budo.map_entry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.map_entry.map_entry">
            function <span class="apidocSignatureSpan">budo.</span>map_entry
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.middleware">module budo.middleware</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.middleware.middleware">
            function <span class="apidocSignatureSpan">budo.</span>middleware
            <span class="apidocSignatureSpan">(entryMiddleware, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.parse_args">module budo.parse_args</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.parse_args.parse_args">
            function <span class="apidocSignatureSpan">budo.</span>parse_args
            <span class="apidocSignatureSpan">(args, opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">budo.parse_args.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.server">module budo.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.server.server">
            function <span class="apidocSignatureSpan">budo.</span>server
            <span class="apidocSignatureSpan">(entryMiddleware, opts, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.simple_http_logger">module budo.simple_http_logger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.simple_http_logger.simple_http_logger">
            function <span class="apidocSignatureSpan">budo.</span>simple_http_logger
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.tinylr">module budo.tinylr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.tinylr.tinylr">
            function <span class="apidocSignatureSpan">budo.</span>tinylr
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.budo.toString">module budo.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.budo.toString.toString">
            function <span class="apidocSignatureSpan">budo.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo" id="apidoc.module.budo">module budo</a></h1>


    <h2>
        <a href="#apidoc.element.budo.budo" id="apidoc.element.budo.budo">
        function <span class="apidocSignatureSpan"></span>budo
        <span class="apidocSignatureSpan">(entries, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBudo(entries, opts) {
  var log = bole('budo')

  // if no entries are specified, just options
  if (entries &amp;&amp; !Array.isArray(entries) &amp;&amp; typeof entries === 'object') {
    opts = entries
    entries = []
  }

  // do not mutate user options
  opts = xtend({}, defaults, { stream: false }, opts)
  entries = entries || []

  // perhaps later this will be configurable
  opts.cwd = process.cwd()

  // log to output stream
  if (opts.stream) {
    // by default, pretty-print to the stream with info logging
    if (!opts.ndjson) {
      var pretty = garnish({
        level: opts.verbose ? 'debug' : 'info',
        name: 'budo'
      })
      pretty.pipe(opts.stream)
      opts.stream = pretty
    }

    bole.output({
      stream: opts.stream,
      level: 'debug'
    })
  }

  // optionally allow as arrays
  entries = [].concat(entries).filter(Boolean)

  var entryObjects = entries.map(mapEntry)
  var entryFiles = entryObjects.map(function (entry) {
    return entry.from
  })

  if (opts.serve &amp;&amp; typeof opts.serve !== 'string') {
    throw new TypeError('opts.serve must be a string or undefined')
  } else if (!opts.serve &amp;&amp; entries.length &gt; 0) {
    opts.serve = entryObjects[0].url
  }

  // default to cwd
  if (!opts.dir || opts.dir.length === 0) {
    opts.dir = opts.cwd
  }

  var emitter = new EventEmitter()
  var bundler, middleware

  if (entries.length &gt; 0 || (opts.browserify &amp;&amp; opts.browserify.entries)) {
    bundler = createBundler(entryFiles, opts)
    middleware = bundler.middleware

    bundler.on('log', function (ev) {
      if (ev.type === 'bundle') {
        var time = ev.elapsed
        ev.elapsed = time
        ev.name = 'browserify'
        ev.type = undefined
        ev.colors = {
          elapsed: time &gt; 1000 ? 'yellow' : 'dim',
          message: 'dim '
        }
        log.info(ev)
      }
    })

    // uncaught syntax errors should not stop the server
    // this only happens when errorHandler: false
    bundler.on('error', function (err) {
      console.error('Error:', err.message ? err.message : err)
    })
    bundler.on('bundle-error', emitter.emit.bind(emitter, 'bundle-error'))
    bundler.on('update', emitter.emit.bind(emitter, 'update'))
    bundler.on('pending', emitter.emit.bind(emitter, 'pending'))

    emitter.on('update', function (contents, deps) {
      if (deps.length &gt; 1) {
        log.debug({
          name: 'browserify',
          message: deps.length + ' files changed'
        })
      }
    })
  }

  var defaultWatchGlob = opts.watchGlob || '**/*.{html,css}'
  var server = null
  var closed = false
  var started = false
  var fileWatcher = null
  var tinylr = null
  var sslOpts = null // needed for livereload
  var deferredWatch = noop
  var deferredLive = noop

  // keep track of the original host
  // (can be undefined)
  var hostAddress = opts.host

  // public API
  emitter.close = once(close)
  emitter.reload = reload
  emitter.live = live
  emitter.watch = watch

  // setup defaults for live reload / watchify
  if (opts.live) {
    emitter
      .watch()
      .live()
      .on('watch', function (ev, file) {
        if (ev !== 'change' &amp;&amp; ev !== 'add') {
          return
        }
        defaultFileEvent(file)
      })
      .on('pending', function () {
        defaultFileEvent(opts.serve)
      })
  }

  // First, setup a server
  createServer(middleware, opts, function (err, serverInstance, httpsCertKey) {
    if (err) {
      emitter.emit('error', err)
      return
    }

    server = serverInstance
    sslOpts = httpsCertKey

    // start portfinding + connect
    getPorts(opts, handlePorts)
  })

  return emitter

  function defaultFileEvent (file) {
    var filename = path.basename(file)
    if ((Array.isArray(opts.live) || typeof opts.live === 'string') &amp;&amp;
        isMatch(filename, opts.live).length === 0) {
      return
    }
    emitter.reload(file)
  }

  function reload (file) {
    process.nextTick(emitter.emit.bind(emitter, 'reload', file))
    if (tinylr) {
      tinylr.reload(file)
    }
  }

  // enable file watch capabilities
  function watc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.bundler" id="apidoc.element.budo.bundler">
        function <span class="apidocSignatureSpan">budo.</span>bundler
        <span class="apidocSignatureSpan">(files, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBundler(files, opts) {
  var bOpts = xtend({
    cache: {},
    packageCache: {},
    debug: opts.debug
  }, opts.browserify)

  var bundler
  var args = opts.browserifyArgs
  if (args &amp;&amp; Array.isArray(args)) {
    // CLI args for browserify
    bundler = fromArgs(args, bOpts)
  } else {
    // just assume JS only options
    bundler = browserify(bOpts)
  }

  files.forEach(function (file) {
    bundler.add(path.resolve(file))
  })

  var errorHandler = opts.errorHandler
  if (typeof errorHandler !== 'function' &amp;&amp; errorHandler !== false) {
    errorHandler = defaultErrorHandler
  }

  var cwd = opts.cwd
  var rootDirName
  if (cwd) {
    cwd = path.normalize(cwd)
    rootDirName = path.basename(cwd) + path.sep
  }
  return createMiddleware(bundler, {
    delay: opts.delay || 0,
    initialBundle: false,
    errorHandler: typeof errorHandler === 'function'
      ? function (err) { // pass along directories as well
        return errorHandler(err, cwd, rootDirName)
      }
      : errorHandler // pass undefined / false / etc
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.cli" id="apidoc.element.budo.cli">
        function <span class="apidocSignatureSpan">budo.</span>cli
        <span class="apidocSignatureSpan">(args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function budoCLI(args, opts) {
  var argv = parseArgs(args, opts)

  // if no stream is specified, default to stdout
  if (argv.stream !== false) {
    argv.stream = /^win/.test(process.platform) ? process.stdout : stdoutStream
  }

  var entries = argv._
  delete argv._

  argv.browserifyArgs = argv['--']
  delete argv['--']

  if (argv.version) {
    console.log('budo v' + require('./package.json').version)
    console.log('browserify v' + require('browserify/package.json').version)
    console.log('watchify v' + require('watchify-middleware').getWatchifyVersion())
    return null
  }

  if (argv.help) {
    var help = require('path').join(__dirname, 'bin', 'help.txt')
    require('fs').createReadStream(help)
      .pipe(process.stdout)
    return null
  }

  if (argv.outfile) {
    console.error(color.yellow('WARNING'), '--outfile has been removed in budo@3.0')
  }

  if (typeof argv.port === 'string') {
    argv.port = parseInt(argv.port, 10)
  }
  if (typeof argv.livePort === 'string') {
    argv.livePort = parseInt(argv.livePort, 10)
  }

  // opts.live can be a glob or a boolean
  if (typeof argv.live === 'string' &amp;&amp; /(true|false)/.test(argv.live)) {
    argv.live = argv.live === 'true'
  }

  // CLI only option for executing a child process
  var instance = budo(entries, argv).on('error', exit)
  var onUpdates = [].concat(argv.onupdate).filter(Boolean)
  onUpdates.forEach(function (cmd) {
    instance.on('update', execFunc(cmd))
  })

  return instance
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.error_handler" id="apidoc.element.budo.error_handler">
        function <span class="apidocSignatureSpan">budo.</span>error_handler
        <span class="apidocSignatureSpan">(err, cwd, rootDirName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function errorHandler(err, cwd, rootDirName) {
  console.error('%s', err)
  var msgStr = stripAnsi(err.message)
  var params = [
    JSON.stringify(msgStr),
    JSON.stringify(cwd),
    JSON.stringify(rootDirName)
  ].join(',')
  return ';(' + bundleError + ')(' + params + ');'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.file_watch" id="apidoc.element.budo.file_watch">
        function <span class="apidocSignatureSpan">budo.</span>file_watch
        <span class="apidocSignatureSpan">(glob, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file_watch = function (glob, opt) {
  opt = xtend({
    usePolling: opt &amp;&amp; opt.poll,
    ignored: ignores,
    ignoreInitial: true
  }, opt)

  var emitter = new Emitter()
  var closed = false
  var ready = false

  var watcher = watch(glob, opt)
  watcher.on('add', onWatch.bind(null, 'add'))
  watcher.on('change', onWatch.bind(null, 'change'))

  // chokidar@1.0.0-r6 only allows close after ready event
  watcher.once('ready', function () {
    ready = true
    if (closed) watcher.close()
  })

  function onWatch (event, path) {
    emitter.emit('watch', event, path)
  }

  emitter.close = function () {
    if (closed) return
    if (ready) watcher.close()
    closed = true
  }
  return emitter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.get_ports" id="apidoc.element.budo.get_ports">
        function <span class="apidocSignatureSpan">budo.</span>get_ports
        <span class="apidocSignatureSpan">(opt, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getServerPorts(opt, cb) {
  opt = xtend({ port: 9966, livePort: 35729 }, opt)

  // try to use exact port specified or the defaults
  if (!opt.portfind) {
    return process.nextTick(function () {
      cb(null, {
        port: opt.port,
        livePort: opt.livePort
      })
    })
  }

  // find our multiple available ports
  getPorts([ opt.port, opt.livePort ], function (err, ports) {
    if (err) return cb(err)
    cb(null, {
      port: ports[0], livePort: ports[1]
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.map_entry" id="apidoc.element.budo.map_entry">
        function <span class="apidocSignatureSpan">budo.</span>map_entry
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapEntry(file) {
  if (file === '.') {
    file = entry()
  }

  var parts
  // absolute path with letter drive, eg C:/
  if (/^[A-Z]:[/\\]+/.test(file)) {
    parts = file.split(/:(?:(?=[^/\\]))/)
  } else {
    parts = file.split(':')
  }

  var pathFrom, pathUrl

  if (parts.length &gt; 1 &amp;&amp; parts[1].length &gt; 0) {
    pathFrom = parts[0]
    pathUrl = parts[1]

    if (pathFrom === '.') {
      pathFrom = entry()
    }
  } else {
    pathFrom = file
    pathUrl = url.parse(path.basename(pathFrom)).pathname
  }

  return {
    url: pathUrl,
    from: pathFrom
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.middleware" id="apidoc.element.budo.middleware">
        function <span class="apidocSignatureSpan">budo.</span>middleware
        <span class="apidocSignatureSpan">(entryMiddleware, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function budoMiddleware(entryMiddleware, opts) {
  opts = opts || {}
  var staticPaths = [].concat(opts.dir).filter(Boolean)
  if (staticPaths.length === 0) {
    staticPaths = [ process.cwd() ]
  }

  var entrySrc = opts.serve
  var live = opts.live
  var cors = opts.cors
  var handler = stacked()
  var middlewares = [].concat(opts.middleware).filter(Boolean)

  // Everything is logged except favicon.ico
  var logHandler = logger({
    ignore: [ '/favicon.ico' ]
  })
  handler.use(function (req, res, next) {
    if (cors) {
      res.setHeader('Access-Control-Allow-Headers', 'Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With
')
      res.setHeader('Access-Control-Allow-Methods', 'GET, PUT, POST')
      res.setHeader('Access-Control-Allow-Origin', '*')
    }
    logHandler(req, res, next)
  })

  // User middleware(s) can override others
  middlewares.forEach(function (middleware) {
    if (typeof middleware !== 'function') {
      throw new Error('middleware options must be functions')
    }
    handler.use(function (req, res, next) {
      logHandler.type = 'middleware'
      middleware(req, res, next)
    })
  })

  // Re-route for pushState support
  if (opts.pushstate) handler.use(pushState())

  // Inject liveReload snippet on response
  var liveInjector = liveReload()
  handler.use(function (req, res, next) {
    if (!live || live.plugin) return next()
    if (live.host) liveInjector.host = live.host
    if (live.port) liveInjector.port = live.port
    liveInjector(req, res, next)
  })

  // Entry (watchify) middleware
  if (entryMiddleware) {
    var entryRoute = '/' + urlLib.parse(entrySrc).pathname
    handler.use(function (req, res, next) {
      if (urlTrim(req.url) === urlTrim(entryRoute)) {
        entryMiddleware(req, res, next)
      } else {
        next()
      }
    })
  }

  // Ignore favicon clutter
  handler.mount('/favicon.ico', favicon)

  // If the user wishes to *always* serve
  // a generated index instead of a static one.
  if (opts.forceDefaultIndex) {
    handler.use(indexHandler)
  }

  // Static assets (html/images/etc)
  staticPaths.forEach(function (rootFile) {
    var staticHandler = serveStatic(rootFile, {
      cacheControl: false
    })
    handler.use(function (req, res, next) {
      logHandler.type = 'static'
      staticHandler(req, res, next)
    })
  })

  // Generates a default index.html
  // when none is found locally.
  handler.use(indexHandler)

  // Handle errors
  handler.use(function (req, res) {
    res.statusCode = 404
    res.end('404 not found: ' + escapeHtml(req.url))
  })

  // Allow live options to be changed at runtime
  handler.setLiveOptions = setLiveOptions
  return handler

  function setLiveOptions (opts) {
    live = opts
  }

  function favicon (req, res) {
    var maxAge = 345600 // 4 days
    res.setHeader('Cache-Control', 'public, max-age=' + Math.floor(maxAge / 1000))
    res.setHeader('Content-Type', 'image/x-icon')
    res.statusCode = 200
    res.end()
  }

  function indexHandler (req, res, next) {
    if (urlLib.parse(req.url).pathname === '/' || /\/index.html?/i.test(req.url)) {
      // If we reach this, our response will be generated
      // (not static from local file system)
      logHandler.type = 'generated'
      res.setHeader('content-type', 'text/html')

      var stream = opts.defaultIndex || defaultIndex
      stream({
        entry: entrySrc,
        title: opts.title,
        css: opts.css,
        base: opts.base === true ? '/' : (opts.base || null)
      }).pipe(res)
    } else {
      next()
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.parse_args" id="apidoc.element.budo.parse_args">
        function <span class="apidocSignatureSpan">budo.</span>parse_args
        <span class="apidocSignatureSpan">(args, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseArgs(args, opt) {
  var argv = minimist(args, {
    boolean: [
      'stream',
      'debug',
      'errorHandler',
      'forceDefaultIndex',
      'open',
      'portfind',
      'pushstate',
      'ndjson',
      'verbose',
      'cors',
      'ssl'
    ],
    string: [
      'host',
      'port',
      'dir',
      'onupdate',
      'serve',
      'title',
      'watchGlob',
      'cert',
      'key'
    ],
    default: module.exports.defaults,
    alias: {
      port: 'p',
      ssl: 'S',
      serve: 's',
      cert: 'C',
      key: 'K',
      verbose: 'v',
      help: 'h',
      host: 'H',
      dir: 'd',
      live: 'l',
      open: 'o',
      watchGlob: [ 'wg', 'watch-glob' ],
      errorHandler: 'error-handler',
      forceDefaultIndex: 'force-default-index',
      'live-port': ['L', 'livePort'],
      pushstate: 'P'
    },
    '--': true
  })
  return xtend(argv, opt)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.server" id="apidoc.element.budo.server">
        function <span class="apidocSignatureSpan">budo.</span>server
        <span class="apidocSignatureSpan">(entryMiddleware, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(entryMiddleware, opts, cb) {
  var handler = createMiddleware(entryMiddleware, opts)
  var ssl = opts.ssl

  if (ssl &amp;&amp; (!opts.cert &amp;&amp; opts.key) || (!opts.key &amp;&amp; opts.cert)) {
    throw new TypeError('If you specify a cert, you must specify a key and vice versa.\n' +
        'Or, you can omit the "cert" and "key" options to generate a new self-signed certificate.')
  }

  if (opts.ssl) {
    if (opts.cert &amp;&amp; opts.key) {
      // user specified their own cert/key pair
      create({
        cert: fs.readFileSync(opts.cert),
        key: fs.readFileSync(opts.key)
      })
    } else {
      // generate a self-signed cert
      pem.createCertificate({ days: 1, selfSigned: true }, function (err, keys) {
        if (err) return cb(err)
        create({
          key: keys.serviceKey,
          cert: keys.certificate
        })
      })
    }
  } else {
    // no HTTPS, handle normally
    create()
  }

  function create (httpsOpts) {
    var server = ssl
      ? https.createServer(httpsOpts, handler)
      : http.createServer(handler)
    server.setLiveOptions = handler.setLiveOptions

    // TODO: Perhaps --ssl should support some sort of HTTP -&gt; HTTPS redirect
    process.nextTick(function () {
      cb(null, server, httpsOpts)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.simple_http_logger" id="apidoc.element.budo.simple_http_logger">
        function <span class="apidocSignatureSpan">budo.</span>simple_http_logger
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function simpleHttpLoggerMiddleware(opts) {
  opts = opts || {}
  var ignores = [].concat(opts.ignore).filter(Boolean)

  var httpLogger = function simpleHttpLogger (req, res, next) {
    if (ignores.indexOf(req.url) &gt;= 0) return next()
    if (!req.url) return next()

    // request data
    req._startAt = undefined

    // response data
    res._startAt = undefined

    // record request start
    recordStartTime.call(req)

    var byteLength = 0
    var logRequest = function () {
      if (!req._startAt || !res._startAt) {
        // missing request and/or response start time
        return
      }

      // calculate diff
      var ms = (res._startAt[0] - req._startAt[0]) * 1000 +
        (res._startAt[1] - req._startAt[1]) * 1e-6

      log.info({
        elapsed: ms,
        contentLength: byteLength,
        method: (req.method || 'GET').toUpperCase(),
        url: req.url,
        statusCode: res.statusCode,
        type: httpLogger.type === 'static' ? undefined : httpLogger.type,
        colors: {
          elapsed: ms &gt; 1000 ? 'yellow' : 'dim'
        }
      })
    }

    var isAlreadyLogging = res._simpleHttpLogger
    res._simpleHttpLogger = true

    if (!isAlreadyLogging) {
      // record response start
      onResHeaders(res, recordStartTime)

      // log when response finished
      onResFinished(res, logRequest)

      var writeFn = res.write

      // catch content-length of payload
      res.write = function (payload) {
        if (payload) byteLength += payload.length
        return writeFn.apply(res, arguments)
      }
    }

    next()
  }

  httpLogger.type = 'static'
  return httpLogger
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.tinylr" id="apidoc.element.budo.tinylr">
        function <span class="apidocSignatureSpan">budo.</span>tinylr
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tinylr = function (opt) {
  opt = xtend(opt)
  if (typeof opt.port !== 'number') {
    opt.port = 35729
  }

  var server = tinylr({
    cert: opt.cert,
    key: opt.key
  })
  var closed = false
  var ready = false

  server.listen(opt.port, opt.host || undefined, function () {
    ready = true
    if (closed) return server.close()
    log.info({ message: 'LiveReload running on ' + opt.port })
  })

  var serverImpl = server.server
  serverImpl.removeAllListeners('error')
  serverImpl.on('error', function (err) {
    if (err.code === 'EADDRINUSE') {
      process.stderr.write('ERROR: livereload not started, port ' + opt.port + ' is in use\n')
    } else {
      process.stderr.write((err.stack ? err.stack : err) + '\n')
    }
    close()
  })

  function close () {
    if (closed) return
    if (ready) server.close()
    closed = true
  }

  return {
    close: close,

    reload: function reload (path) {
      try {
        server.changed({
          body: {
            files: path ? [ path ] : '*'
          }
        })
      } catch (e) {
        throw e
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.toString" id="apidoc.element.budo.toString">
        function <span class="apidocSignatureSpan">budo.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.bundler" id="apidoc.module.budo.bundler">module budo.bundler</a></h1>


    <h2>
        <a href="#apidoc.element.budo.bundler.bundler" id="apidoc.element.budo.bundler.bundler">
        function <span class="apidocSignatureSpan">budo.</span>bundler
        <span class="apidocSignatureSpan">(files, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBundler(files, opts) {
  var bOpts = xtend({
    cache: {},
    packageCache: {},
    debug: opts.debug
  }, opts.browserify)

  var bundler
  var args = opts.browserifyArgs
  if (args &amp;&amp; Array.isArray(args)) {
    // CLI args for browserify
    bundler = fromArgs(args, bOpts)
  } else {
    // just assume JS only options
    bundler = browserify(bOpts)
  }

  files.forEach(function (file) {
    bundler.add(path.resolve(file))
  })

  var errorHandler = opts.errorHandler
  if (typeof errorHandler !== 'function' &amp;&amp; errorHandler !== false) {
    errorHandler = defaultErrorHandler
  }

  var cwd = opts.cwd
  var rootDirName
  if (cwd) {
    cwd = path.normalize(cwd)
    rootDirName = path.basename(cwd) + path.sep
  }
  return createMiddleware(bundler, {
    delay: opts.delay || 0,
    initialBundle: false,
    errorHandler: typeof errorHandler === 'function'
      ? function (err) { // pass along directories as well
        return errorHandler(err, cwd, rootDirName)
      }
      : errorHandler // pass undefined / false / etc
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.cli" id="apidoc.module.budo.cli">module budo.cli</a></h1>


    <h2>
        <a href="#apidoc.element.budo.cli.cli" id="apidoc.element.budo.cli.cli">
        function <span class="apidocSignatureSpan">budo.</span>cli
        <span class="apidocSignatureSpan">(args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function budoCLI(args, opts) {
  var argv = parseArgs(args, opts)

  // if no stream is specified, default to stdout
  if (argv.stream !== false) {
    argv.stream = /^win/.test(process.platform) ? process.stdout : stdoutStream
  }

  var entries = argv._
  delete argv._

  argv.browserifyArgs = argv['--']
  delete argv['--']

  if (argv.version) {
    console.log('budo v' + require('./package.json').version)
    console.log('browserify v' + require('browserify/package.json').version)
    console.log('watchify v' + require('watchify-middleware').getWatchifyVersion())
    return null
  }

  if (argv.help) {
    var help = require('path').join(__dirname, 'bin', 'help.txt')
    require('fs').createReadStream(help)
      .pipe(process.stdout)
    return null
  }

  if (argv.outfile) {
    console.error(color.yellow('WARNING'), '--outfile has been removed in budo@3.0')
  }

  if (typeof argv.port === 'string') {
    argv.port = parseInt(argv.port, 10)
  }
  if (typeof argv.livePort === 'string') {
    argv.livePort = parseInt(argv.livePort, 10)
  }

  // opts.live can be a glob or a boolean
  if (typeof argv.live === 'string' &amp;&amp; /(true|false)/.test(argv.live)) {
    argv.live = argv.live === 'true'
  }

  // CLI only option for executing a child process
  var instance = budo(entries, argv).on('error', exit)
  var onUpdates = [].concat(argv.onupdate).filter(Boolean)
  onUpdates.forEach(function (cmd) {
    instance.on('update', execFunc(cmd))
  })

  return instance
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.error_handler" id="apidoc.module.budo.error_handler">module budo.error_handler</a></h1>


    <h2>
        <a href="#apidoc.element.budo.error_handler.error_handler" id="apidoc.element.budo.error_handler.error_handler">
        function <span class="apidocSignatureSpan">budo.</span>error_handler
        <span class="apidocSignatureSpan">(err, cwd, rootDirName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function errorHandler(err, cwd, rootDirName) {
  console.error('%s', err)
  var msgStr = stripAnsi(err.message)
  var params = [
    JSON.stringify(msgStr),
    JSON.stringify(cwd),
    JSON.stringify(rootDirName)
  ].join(',')
  return ';(' + bundleError + ')(' + params + ');'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.budo.error_handler.render" id="apidoc.element.budo.error_handler.render">
        function <span class="apidocSignatureSpan">budo.error_handler.</span>render
        <span class="apidocSignatureSpan">(message, cwd, rootDirName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bundleError(message, cwd, rootDirName) {
  // Everything has to be contained inside this function
  // for it to get stringified correctly. i.e. no require()!
  console.error(message)

  if (typeof document === 'undefined') {
    return
  } else if (!document.body) {
    document.addEventListener('DOMContentLoaded', createErrorBox)
  } else {
    createErrorBox()
  }

  function createErrorBox () {
    var parsed = parseError(message)

    var overlayBox = document.createElement('div')
    css(overlayBox, {
      position: 'fixed',
      width: '100%',
      height: '100%',
      zIndex: '100000000',
      top: '0',
      left: '0',
      padding: '20px',
      margin: '0px',
      'box-sizing': 'border-box',
      background: '#fff',
      display: 'block',
      'font-size': '14px',
      'font-weight': 'normal',
      'font-family': 'monospace'
    })

    if (!parsed.format) {
      var pre = document.createElement('pre')
      pre.textContent = message
      css(pre, {
        'word-wrap': 'break-word',
        'white-space': 'pre-wrap',
        'box-sizing': 'border-box',
        margin: '0',
        color: '#ff0000'
      })
      overlayBox.appendChild(pre)
    } else {
      var commonElements = []

      var messageDiv = document.createElement('div')
      commonElements.push(messageDiv)
      messageDiv.textContent = parsed.message
      overlayBox.appendChild(messageDiv)
      css(messageDiv, {
        color: '#ff2e2e',
        'font-size': '16px'
      })

      var pathLocContainer = document.createElement('div')
      css(pathLocContainer, { 'padding-top': '10px' })

      if (isFinite(parsed.line)) {
        var location = document.createElement('div')
        commonElements.push(location)
        var colStr = isFinite(parsed.column) ? (', column ' + parsed.column) : ''
        location.textContent = ('line ' + parsed.line + colStr).trim()
        css(location, {
          color: 'hsl(0, 0%, 50%)',
          'padding-bottom': '0px',
          'font-size': '12px',
          'font-weight': 'bold'
        })
        pathLocContainer.appendChild(location)
      }

      var path = document.createElement('div')
      path.textContent = trimPath(parsed.path)
      commonElements.push(path)
      css(path, { 'font-style': 'italic' })
      pathLocContainer.appendChild(path)
      overlayBox.appendChild(pathLocContainer)

      if (parsed.code) {
        var sourceContainer = document.createElement('div')
        var source = document.createElement('div')
        var hr = document.createElement('div')
        css(hr, {
          background: 'hsl(0, 0%, 90%)',
          width: '100%',
          height: '2px',
          padding: '0',
          'margin-bottom': '10px',
          'margin-top': '10px'
        })
        commonElements.push(source)
        source.textContent = parsed.code
        css(source, {
          color: 'black',
          'font-weight': 'bold',
          'font-size': '14px',
          'padding-left': '0px'
        })

        sourceContainer.appendChild(hr)
        sourceContainer.appendChild(source)
        overlayBox.appendChild(sourceContainer)
      }

      // apply common styles
      commonElements.forEach(function (e) {
        css(e, {
          'word-wrap': 'break-word',
          'white-space': 'pre-wrap',
          'box-sizing': 'border-box',
          display: 'block',
          margin: '0',
          'vertical-align': 'bottom'
        })
      })
    }
    document.body.appendChild(overlayBox)
  }

  function trimPath (filePath) {
    if (filePath.indexOf(cwd) === 0) {
      filePath = rootDirName + filePath.substring(cwd.length + 1)
    }
    return filePath
  }

  function css (element, style) {
    Object.keys(style).forEach(function (k) {
      element.style[k] = style[k]
    })
  }

  // parse an error message into pieces
  function parseError (err) {
    var filePath, lineNum, splitLines
    var result = {}

    // For root files that syntax-error doesn't pick up:
    var parseFilePrefix = 'Parsing file '
    if (err.indexOf(parseFilePrefix) === 0) {
      var pathWi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.file_watch" id="apidoc.module.budo.file_watch">module budo.file_watch</a></h1>


    <h2>
        <a href="#apidoc.element.budo.file_watch.file_watch" id="apidoc.element.budo.file_watch.file_watch">
        function <span class="apidocSignatureSpan">budo.</span>file_watch
        <span class="apidocSignatureSpan">(glob, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file_watch = function (glob, opt) {
  opt = xtend({
    usePolling: opt &amp;&amp; opt.poll,
    ignored: ignores,
    ignoreInitial: true
  }, opt)

  var emitter = new Emitter()
  var closed = false
  var ready = false

  var watcher = watch(glob, opt)
  watcher.on('add', onWatch.bind(null, 'add'))
  watcher.on('change', onWatch.bind(null, 'change'))

  // chokidar@1.0.0-r6 only allows close after ready event
  watcher.once('ready', function () {
    ready = true
    if (closed) watcher.close()
  })

  function onWatch (event, path) {
    emitter.emit('watch', event, path)
  }

  emitter.close = function () {
    if (closed) return
    if (ready) watcher.close()
    closed = true
  }
  return emitter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.get_ports" id="apidoc.module.budo.get_ports">module budo.get_ports</a></h1>


    <h2>
        <a href="#apidoc.element.budo.get_ports.get_ports" id="apidoc.element.budo.get_ports.get_ports">
        function <span class="apidocSignatureSpan">budo.</span>get_ports
        <span class="apidocSignatureSpan">(opt, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getServerPorts(opt, cb) {
  opt = xtend({ port: 9966, livePort: 35729 }, opt)

  // try to use exact port specified or the defaults
  if (!opt.portfind) {
    return process.nextTick(function () {
      cb(null, {
        port: opt.port,
        livePort: opt.livePort
      })
    })
  }

  // find our multiple available ports
  getPorts([ opt.port, opt.livePort ], function (err, ports) {
    if (err) return cb(err)
    cb(null, {
      port: ports[0], livePort: ports[1]
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.map_entry" id="apidoc.module.budo.map_entry">module budo.map_entry</a></h1>


    <h2>
        <a href="#apidoc.element.budo.map_entry.map_entry" id="apidoc.element.budo.map_entry.map_entry">
        function <span class="apidocSignatureSpan">budo.</span>map_entry
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapEntry(file) {
  if (file === '.') {
    file = entry()
  }

  var parts
  // absolute path with letter drive, eg C:/
  if (/^[A-Z]:[/\\]+/.test(file)) {
    parts = file.split(/:(?:(?=[^/\\]))/)
  } else {
    parts = file.split(':')
  }

  var pathFrom, pathUrl

  if (parts.length &gt; 1 &amp;&amp; parts[1].length &gt; 0) {
    pathFrom = parts[0]
    pathUrl = parts[1]

    if (pathFrom === '.') {
      pathFrom = entry()
    }
  } else {
    pathFrom = file
    pathUrl = url.parse(path.basename(pathFrom)).pathname
  }

  return {
    url: pathUrl,
    from: pathFrom
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.middleware" id="apidoc.module.budo.middleware">module budo.middleware</a></h1>


    <h2>
        <a href="#apidoc.element.budo.middleware.middleware" id="apidoc.element.budo.middleware.middleware">
        function <span class="apidocSignatureSpan">budo.</span>middleware
        <span class="apidocSignatureSpan">(entryMiddleware, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function budoMiddleware(entryMiddleware, opts) {
  opts = opts || {}
  var staticPaths = [].concat(opts.dir).filter(Boolean)
  if (staticPaths.length === 0) {
    staticPaths = [ process.cwd() ]
  }

  var entrySrc = opts.serve
  var live = opts.live
  var cors = opts.cors
  var handler = stacked()
  var middlewares = [].concat(opts.middleware).filter(Boolean)

  // Everything is logged except favicon.ico
  var logHandler = logger({
    ignore: [ '/favicon.ico' ]
  })
  handler.use(function (req, res, next) {
    if (cors) {
      res.setHeader('Access-Control-Allow-Headers', 'Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With
')
      res.setHeader('Access-Control-Allow-Methods', 'GET, PUT, POST')
      res.setHeader('Access-Control-Allow-Origin', '*')
    }
    logHandler(req, res, next)
  })

  // User middleware(s) can override others
  middlewares.forEach(function (middleware) {
    if (typeof middleware !== 'function') {
      throw new Error('middleware options must be functions')
    }
    handler.use(function (req, res, next) {
      logHandler.type = 'middleware'
      middleware(req, res, next)
    })
  })

  // Re-route for pushState support
  if (opts.pushstate) handler.use(pushState())

  // Inject liveReload snippet on response
  var liveInjector = liveReload()
  handler.use(function (req, res, next) {
    if (!live || live.plugin) return next()
    if (live.host) liveInjector.host = live.host
    if (live.port) liveInjector.port = live.port
    liveInjector(req, res, next)
  })

  // Entry (watchify) middleware
  if (entryMiddleware) {
    var entryRoute = '/' + urlLib.parse(entrySrc).pathname
    handler.use(function (req, res, next) {
      if (urlTrim(req.url) === urlTrim(entryRoute)) {
        entryMiddleware(req, res, next)
      } else {
        next()
      }
    })
  }

  // Ignore favicon clutter
  handler.mount('/favicon.ico', favicon)

  // If the user wishes to *always* serve
  // a generated index instead of a static one.
  if (opts.forceDefaultIndex) {
    handler.use(indexHandler)
  }

  // Static assets (html/images/etc)
  staticPaths.forEach(function (rootFile) {
    var staticHandler = serveStatic(rootFile, {
      cacheControl: false
    })
    handler.use(function (req, res, next) {
      logHandler.type = 'static'
      staticHandler(req, res, next)
    })
  })

  // Generates a default index.html
  // when none is found locally.
  handler.use(indexHandler)

  // Handle errors
  handler.use(function (req, res) {
    res.statusCode = 404
    res.end('404 not found: ' + escapeHtml(req.url))
  })

  // Allow live options to be changed at runtime
  handler.setLiveOptions = setLiveOptions
  return handler

  function setLiveOptions (opts) {
    live = opts
  }

  function favicon (req, res) {
    var maxAge = 345600 // 4 days
    res.setHeader('Cache-Control', 'public, max-age=' + Math.floor(maxAge / 1000))
    res.setHeader('Content-Type', 'image/x-icon')
    res.statusCode = 200
    res.end()
  }

  function indexHandler (req, res, next) {
    if (urlLib.parse(req.url).pathname === '/' || /\/index.html?/i.test(req.url)) {
      // If we reach this, our response will be generated
      // (not static from local file system)
      logHandler.type = 'generated'
      res.setHeader('content-type', 'text/html')

      var stream = opts.defaultIndex || defaultIndex
      stream({
        entry: entrySrc,
        title: opts.title,
        css: opts.css,
        base: opts.base === true ? '/' : (opts.base || null)
      }).pipe(res)
    } else {
      next()
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.parse_args" id="apidoc.module.budo.parse_args">module budo.parse_args</a></h1>


    <h2>
        <a href="#apidoc.element.budo.parse_args.parse_args" id="apidoc.element.budo.parse_args.parse_args">
        function <span class="apidocSignatureSpan">budo.</span>parse_args
        <span class="apidocSignatureSpan">(args, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseArgs(args, opt) {
  var argv = minimist(args, {
    boolean: [
      'stream',
      'debug',
      'errorHandler',
      'forceDefaultIndex',
      'open',
      'portfind',
      'pushstate',
      'ndjson',
      'verbose',
      'cors',
      'ssl'
    ],
    string: [
      'host',
      'port',
      'dir',
      'onupdate',
      'serve',
      'title',
      'watchGlob',
      'cert',
      'key'
    ],
    default: module.exports.defaults,
    alias: {
      port: 'p',
      ssl: 'S',
      serve: 's',
      cert: 'C',
      key: 'K',
      verbose: 'v',
      help: 'h',
      host: 'H',
      dir: 'd',
      live: 'l',
      open: 'o',
      watchGlob: [ 'wg', 'watch-glob' ],
      errorHandler: 'error-handler',
      forceDefaultIndex: 'force-default-index',
      'live-port': ['L', 'livePort'],
      pushstate: 'P'
    },
    '--': true
  })
  return xtend(argv, opt)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.server" id="apidoc.module.budo.server">module budo.server</a></h1>


    <h2>
        <a href="#apidoc.element.budo.server.server" id="apidoc.element.budo.server.server">
        function <span class="apidocSignatureSpan">budo.</span>server
        <span class="apidocSignatureSpan">(entryMiddleware, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(entryMiddleware, opts, cb) {
  var handler = createMiddleware(entryMiddleware, opts)
  var ssl = opts.ssl

  if (ssl &amp;&amp; (!opts.cert &amp;&amp; opts.key) || (!opts.key &amp;&amp; opts.cert)) {
    throw new TypeError('If you specify a cert, you must specify a key and vice versa.\n' +
        'Or, you can omit the "cert" and "key" options to generate a new self-signed certificate.')
  }

  if (opts.ssl) {
    if (opts.cert &amp;&amp; opts.key) {
      // user specified their own cert/key pair
      create({
        cert: fs.readFileSync(opts.cert),
        key: fs.readFileSync(opts.key)
      })
    } else {
      // generate a self-signed cert
      pem.createCertificate({ days: 1, selfSigned: true }, function (err, keys) {
        if (err) return cb(err)
        create({
          key: keys.serviceKey,
          cert: keys.certificate
        })
      })
    }
  } else {
    // no HTTPS, handle normally
    create()
  }

  function create (httpsOpts) {
    var server = ssl
      ? https.createServer(httpsOpts, handler)
      : http.createServer(handler)
    server.setLiveOptions = handler.setLiveOptions

    // TODO: Perhaps --ssl should support some sort of HTTP -&gt; HTTPS redirect
    process.nextTick(function () {
      cb(null, server, httpsOpts)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.simple_http_logger" id="apidoc.module.budo.simple_http_logger">module budo.simple_http_logger</a></h1>


    <h2>
        <a href="#apidoc.element.budo.simple_http_logger.simple_http_logger" id="apidoc.element.budo.simple_http_logger.simple_http_logger">
        function <span class="apidocSignatureSpan">budo.</span>simple_http_logger
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function simpleHttpLoggerMiddleware(opts) {
  opts = opts || {}
  var ignores = [].concat(opts.ignore).filter(Boolean)

  var httpLogger = function simpleHttpLogger (req, res, next) {
    if (ignores.indexOf(req.url) &gt;= 0) return next()
    if (!req.url) return next()

    // request data
    req._startAt = undefined

    // response data
    res._startAt = undefined

    // record request start
    recordStartTime.call(req)

    var byteLength = 0
    var logRequest = function () {
      if (!req._startAt || !res._startAt) {
        // missing request and/or response start time
        return
      }

      // calculate diff
      var ms = (res._startAt[0] - req._startAt[0]) * 1000 +
        (res._startAt[1] - req._startAt[1]) * 1e-6

      log.info({
        elapsed: ms,
        contentLength: byteLength,
        method: (req.method || 'GET').toUpperCase(),
        url: req.url,
        statusCode: res.statusCode,
        type: httpLogger.type === 'static' ? undefined : httpLogger.type,
        colors: {
          elapsed: ms &gt; 1000 ? 'yellow' : 'dim'
        }
      })
    }

    var isAlreadyLogging = res._simpleHttpLogger
    res._simpleHttpLogger = true

    if (!isAlreadyLogging) {
      // record response start
      onResHeaders(res, recordStartTime)

      // log when response finished
      onResFinished(res, logRequest)

      var writeFn = res.write

      // catch content-length of payload
      res.write = function (payload) {
        if (payload) byteLength += payload.length
        return writeFn.apply(res, arguments)
      }
    }

    next()
  }

  httpLogger.type = 'static'
  return httpLogger
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.tinylr" id="apidoc.module.budo.tinylr">module budo.tinylr</a></h1>


    <h2>
        <a href="#apidoc.element.budo.tinylr.tinylr" id="apidoc.element.budo.tinylr.tinylr">
        function <span class="apidocSignatureSpan">budo.</span>tinylr
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tinylr = function (opt) {
  opt = xtend(opt)
  if (typeof opt.port !== 'number') {
    opt.port = 35729
  }

  var server = tinylr({
    cert: opt.cert,
    key: opt.key
  })
  var closed = false
  var ready = false

  server.listen(opt.port, opt.host || undefined, function () {
    ready = true
    if (closed) return server.close()
    log.info({ message: 'LiveReload running on ' + opt.port })
  })

  var serverImpl = server.server
  serverImpl.removeAllListeners('error')
  serverImpl.on('error', function (err) {
    if (err.code === 'EADDRINUSE') {
      process.stderr.write('ERROR: livereload not started, port ' + opt.port + ' is in use\n')
    } else {
      process.stderr.write((err.stack ? err.stack : err) + '\n')
    }
    close()
  })

  function close () {
    if (closed) return
    if (ready) server.close()
    closed = true
  }

  return {
    close: close,

    reload: function reload (path) {
      try {
        server.changed({
          body: {
            files: path ? [ path ] : '*'
          }
        })
      } catch (e) {
        throw e
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.budo.toString" id="apidoc.module.budo.toString">module budo.toString</a></h1>


    <h2>
        <a href="#apidoc.element.budo.toString.toString" id="apidoc.element.budo.toString.toString">
        function <span class="apidocSignatureSpan">budo.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>